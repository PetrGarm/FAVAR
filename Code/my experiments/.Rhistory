fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3])
View(fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3]))
forecast_class_consturctor <- function(forecast, model, method)
{
# Construct output list
output <- list(forecast=forecast, model=model, method = method)
# Return with forecasting class
return(structure(output, class='forecast'))
}
fore_FAVAR <- function(X, Y, X_slow, K, num_y, num_i, h, y){
start <- start(X)
frequency <- frequency(X)
X = X[1:length(y),]
Y = Y[1:length(y),]
X_slow = X_slow[1:length(y),]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
# extract PC from X
XtX = t(X) %*% X
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
lam <- 1/sqrt(N) * eig_vec[,(1:K)]
F0 <- data.matrix(X) %*% lam
#extract PC from X_slow
XtX = t(X_slow) %*% X_slow
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
nslow <- dim(X_slow)[2]
lam <- 1 / sqrt(nslow) * eig_vec[,(1:K)]
Fslow0 <- data.matrix(X_slow) %*% lam
# Factors rotation
ones_vec = rep(1, T)
Ffast = data.matrix(Y[,num_i]) # interest rate
k1 = dim(Ffast)[2] # (num of Ffast)
ly = cbind(ones_vec, Ffast, Fslow0)
svd <- svd(ly)
vl <-svd$u
d <- 1 / svd$d
vr <- svd$v
b = (vr * matrix(data = rep(d, dim(vr)[1]), ncol = dim(vr)[1], byrow = TRUE)) %*% (t(vl) %*% F0)
Ffast_ktimes = matrix(rep(Ffast, K), ncol = K)
coeffs = matrix(rep(b[2:(k1+1),], dim(Ffast_ktimes)[1]), ncol=K, byrow = TRUE)
Fr = F0 - Ffast_ktimes*coeffs
# FAVAR with clean factors
Y_for_VAR = cbind(Fr, Y)
factor_names <- c(1:K)
for(i in 1:K) {
factor_names[i] = paste('factor', as.character(i), sep='')
}
colnames(Y_for_VAR)[1:K] <- factor_names
Y_for_VAR <- ts(Y_for_VAR, start = start, frequency = frequency)
VARselect(Y_for_VAR)
p = VARselect(Y_for_VAR)$selection[1] # according AIC
var <- VAR(Y_for_VAR, p)
y_hat <- forecast(var, h=h)
forecast_class <- forecast_class_consturctor(forecast = y_hat$forecast[K+num_y],
model = var,
method = y_hat$method[K+num_y])
return(forecast_class)
}
fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3])
forecast_class_consturctor <- function(forecast, model, method)
{
# Construct output list
output <- list(mean=forecast, model=model, method = method)
# Return with forecasting class
return(structure(output, class='forecast'))
}
fore_FAVAR <- function(X, Y, X_slow, K, num_y, num_i, h, y){
start <- start(X)
frequency <- frequency(X)
X = X[1:length(y),]
Y = Y[1:length(y),]
X_slow = X_slow[1:length(y),]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
# extract PC from X
XtX = t(X) %*% X
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
lam <- 1/sqrt(N) * eig_vec[,(1:K)]
F0 <- data.matrix(X) %*% lam
#extract PC from X_slow
XtX = t(X_slow) %*% X_slow
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
nslow <- dim(X_slow)[2]
lam <- 1 / sqrt(nslow) * eig_vec[,(1:K)]
Fslow0 <- data.matrix(X_slow) %*% lam
# Factors rotation
ones_vec = rep(1, T)
Ffast = data.matrix(Y[,num_i]) # interest rate
k1 = dim(Ffast)[2] # (num of Ffast)
ly = cbind(ones_vec, Ffast, Fslow0)
svd <- svd(ly)
vl <-svd$u
d <- 1 / svd$d
vr <- svd$v
b = (vr * matrix(data = rep(d, dim(vr)[1]), ncol = dim(vr)[1], byrow = TRUE)) %*% (t(vl) %*% F0)
Ffast_ktimes = matrix(rep(Ffast, K), ncol = K)
coeffs = matrix(rep(b[2:(k1+1),], dim(Ffast_ktimes)[1]), ncol=K, byrow = TRUE)
Fr = F0 - Ffast_ktimes*coeffs
# FAVAR with clean factors
Y_for_VAR = cbind(Fr, Y)
factor_names <- c(1:K)
for(i in 1:K) {
factor_names[i] = paste('factor', as.character(i), sep='')
}
colnames(Y_for_VAR)[1:K] <- factor_names
Y_for_VAR <- ts(Y_for_VAR, start = start, frequency = frequency)
VARselect(Y_for_VAR)
p = VARselect(Y_for_VAR)$selection[1] # according AIC
var <- VAR(Y_for_VAR, p)
y_hat <- forecast(var, h=h)
forecast_class <- forecast_class_consturctor(forecast = y_hat$forecast[K+num_y],
model = var,
method = y_hat$method[K+num_y])
return(forecast_class)
}
fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3])
View(fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3]))
forecast_class_consturctor <- function(forecast, model, method)
{
# Construct output list
output <- list(forecast=c(forecast), model=model, method = method)
# Return with forecasting class
return(structure(output, class='forecast'))
}
forecast_class_consturctor <- function(forecast, model, method){
# Construct output list
output <- list(forecast=c(forecast), model=model, method = method)
# Return with forecasting class
return(structure(output, class='forecast'))
}
fore_FAVAR <- function(X, Y, X_slow, K, num_y, num_i, h, y){
start <- start(X)
frequency <- frequency(X)
X = X[1:length(y),]
Y = Y[1:length(y),]
X_slow = X_slow[1:length(y),]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
# extract PC from X
XtX = t(X) %*% X
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
lam <- 1/sqrt(N) * eig_vec[,(1:K)]
F0 <- data.matrix(X) %*% lam
#extract PC from X_slow
XtX = t(X_slow) %*% X_slow
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
nslow <- dim(X_slow)[2]
lam <- 1 / sqrt(nslow) * eig_vec[,(1:K)]
Fslow0 <- data.matrix(X_slow) %*% lam
# Factors rotation
ones_vec = rep(1, T)
Ffast = data.matrix(Y[,num_i]) # interest rate
k1 = dim(Ffast)[2] # (num of Ffast)
ly = cbind(ones_vec, Ffast, Fslow0)
svd <- svd(ly)
vl <-svd$u
d <- 1 / svd$d
vr <- svd$v
b = (vr * matrix(data = rep(d, dim(vr)[1]), ncol = dim(vr)[1], byrow = TRUE)) %*% (t(vl) %*% F0)
Ffast_ktimes = matrix(rep(Ffast, K), ncol = K)
coeffs = matrix(rep(b[2:(k1+1),], dim(Ffast_ktimes)[1]), ncol=K, byrow = TRUE)
Fr = F0 - Ffast_ktimes*coeffs
# FAVAR with clean factors
Y_for_VAR = cbind(Fr, Y)
factor_names <- c(1:K)
for(i in 1:K) {
factor_names[i] = paste('factor', as.character(i), sep='')
}
colnames(Y_for_VAR)[1:K] <- factor_names
Y_for_VAR <- ts(Y_for_VAR, start = start, frequency = frequency)
VARselect(Y_for_VAR)
p = VARselect(Y_for_VAR)$selection[1] # according AIC
var <- VAR(Y_for_VAR, p)
y_hat <- forecast(var, h=h)
forecast_class <- forecast_class_consturctor(forecast = y_hat$forecast[K+num_y],
model = var,
method = y_hat$method[K+num_y])
return(forecast_class)
}
fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3])
y_hat$forecast$Y.IP
forecast_class_consturctor <- function(forecast, model, method){
# Construct output list
output <- list(forecast=list(forecast), model=model, method = method)
# Return with forecasting class
return(structure(output, class='forecast'))
}
fore_FAVAR <- function(X, Y, X_slow, K, num_y, num_i, h, y){
start <- start(X)
frequency <- frequency(X)
X = X[1:length(y),]
Y = Y[1:length(y),]
X_slow = X_slow[1:length(y),]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
# extract PC from X
XtX = t(X) %*% X
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
lam <- 1/sqrt(N) * eig_vec[,(1:K)]
F0 <- data.matrix(X) %*% lam
#extract PC from X_slow
XtX = t(X_slow) %*% X_slow
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
nslow <- dim(X_slow)[2]
lam <- 1 / sqrt(nslow) * eig_vec[,(1:K)]
Fslow0 <- data.matrix(X_slow) %*% lam
# Factors rotation
ones_vec = rep(1, T)
Ffast = data.matrix(Y[,num_i]) # interest rate
k1 = dim(Ffast)[2] # (num of Ffast)
ly = cbind(ones_vec, Ffast, Fslow0)
svd <- svd(ly)
vl <-svd$u
d <- 1 / svd$d
vr <- svd$v
b = (vr * matrix(data = rep(d, dim(vr)[1]), ncol = dim(vr)[1], byrow = TRUE)) %*% (t(vl) %*% F0)
Ffast_ktimes = matrix(rep(Ffast, K), ncol = K)
coeffs = matrix(rep(b[2:(k1+1),], dim(Ffast_ktimes)[1]), ncol=K, byrow = TRUE)
Fr = F0 - Ffast_ktimes*coeffs
# FAVAR with clean factors
Y_for_VAR = cbind(Fr, Y)
factor_names <- c(1:K)
for(i in 1:K) {
factor_names[i] = paste('factor', as.character(i), sep='')
}
colnames(Y_for_VAR)[1:K] <- factor_names
Y_for_VAR <- ts(Y_for_VAR, start = start, frequency = frequency)
VARselect(Y_for_VAR)
p = VARselect(Y_for_VAR)$selection[1] # according AIC
var <- VAR(Y_for_VAR, p)
y_hat <- forecast(var, h=h)
forecast_class <- forecast_class_consturctor(forecast = y_hat$forecast[K+num_y],
model = var,
method = y_hat$method[K+num_y])
return(forecast_class)
}
fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3])
forecast_class_consturctor <- function(forecast, model, method){
# Construct output list
output <- list(model=model, method = method)
# Return with forecasting class
return(structure(output, class='forecast'))
}
fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3])
class(y_hat$forecast)
list(y_hat$forecast[1])
c(y_hat$forecast[1])
list(y_hat$forecast[1])
list(Fr.Series.1 = y_hat$forecast$Fr.Series.1)
list(1,2)
a = list()
?list
forecast_class_consturctor <- function(forecast, model, method, y_name){
# Construct output list
forecast <- list(y_name = forecast)
output <- list(model=model, forecast = forecast, method = method)
# Return with forecasting class
return(structure(output, class='forecast'))
}
fore_FAVAR <- function(X, Y, X_slow, K, num_y, num_i, h, y){
start <- start(X)
frequency <- frequency(X)
X = X[1:length(y),]
Y = Y[1:length(y),]
X_slow = X_slow[1:length(y),]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
# extract PC from X
XtX = t(X) %*% X
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
lam <- 1/sqrt(N) * eig_vec[,(1:K)]
F0 <- data.matrix(X) %*% lam
#extract PC from X_slow
XtX = t(X_slow) %*% X_slow
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
nslow <- dim(X_slow)[2]
lam <- 1 / sqrt(nslow) * eig_vec[,(1:K)]
Fslow0 <- data.matrix(X_slow) %*% lam
# Factors rotation
ones_vec = rep(1, T)
Ffast = data.matrix(Y[,num_i]) # interest rate
k1 = dim(Ffast)[2] # (num of Ffast)
ly = cbind(ones_vec, Ffast, Fslow0)
svd <- svd(ly)
vl <-svd$u
d <- 1 / svd$d
vr <- svd$v
b = (vr * matrix(data = rep(d, dim(vr)[1]), ncol = dim(vr)[1], byrow = TRUE)) %*% (t(vl) %*% F0)
Ffast_ktimes = matrix(rep(Ffast, K), ncol = K)
coeffs = matrix(rep(b[2:(k1+1),], dim(Ffast_ktimes)[1]), ncol=K, byrow = TRUE)
Fr = F0 - Ffast_ktimes*coeffs
# FAVAR with clean factors
Y_for_VAR = cbind(Fr, Y)
factor_names <- c(1:K)
for(i in 1:K) {
factor_names[i] = paste('factor', as.character(i), sep='')
}
colnames(Y_for_VAR)[1:K] <- factor_names
Y_for_VAR <- ts(Y_for_VAR, start = start, frequency = frequency)
VARselect(Y_for_VAR)
p = VARselect(Y_for_VAR)$selection[1] # according AIC
var <- VAR(Y_for_VAR, p)
y_hat <- forecast(var, h=h)
y_name <- colnames(Y_for_VAR)[K+num_y]
forecast_class <- forecast_class_consturctor(
forecast = list(y_name = y_hat$forecast[y_name]),
model = var,
method = y_hat$method[K+num_y], y_name=y_name)
return(forecast_class)
}
fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3])
forecast_class_consturctor(y_hat$forecast$Y.IP, model = var, method = y_hat$method[1], y_name = "Y.IP")
fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3])
fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3])
fore_FAVAR <- function(X, Y, X_slow, K, num_y, num_i, h, y){
start <- start(X)
frequency <- frequency(X)
X = X[1:length(y),]
Y = Y[1:length(y),]
X_slow = X_slow[1:length(y),]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
N = dim(X)[2]
M = dim(Y)[2]
T = dim(X)[1]
# extract PC from X
XtX = t(X) %*% X
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
lam <- 1/sqrt(N) * eig_vec[,(1:K)]
F0 <- data.matrix(X) %*% lam
#extract PC from X_slow
XtX = t(X_slow) %*% X_slow
spectral_decomposition <- eigen(XtX)
eig_vec <- spectral_decomposition$vectors
eig_val <- spectral_decomposition$values
nslow <- dim(X_slow)[2]
lam <- 1 / sqrt(nslow) * eig_vec[,(1:K)]
Fslow0 <- data.matrix(X_slow) %*% lam
# Factors rotation
ones_vec = rep(1, T)
Ffast = data.matrix(Y[,num_i]) # interest rate
k1 = dim(Ffast)[2] # (num of Ffast)
ly = cbind(ones_vec, Ffast, Fslow0)
svd <- svd(ly)
vl <-svd$u
d <- 1 / svd$d
vr <- svd$v
b = (vr * matrix(data = rep(d, dim(vr)[1]), ncol = dim(vr)[1], byrow = TRUE)) %*% (t(vl) %*% F0)
Ffast_ktimes = matrix(rep(Ffast, K), ncol = K)
coeffs = matrix(rep(b[2:(k1+1),], dim(Ffast_ktimes)[1]), ncol=K, byrow = TRUE)
Fr = F0 - Ffast_ktimes*coeffs
# FAVAR with clean factors
Y_for_VAR = cbind(Fr, Y)
factor_names <- c(1:K)
for(i in 1:K) {
factor_names[i] = paste('factor', as.character(i), sep='')
}
colnames(Y_for_VAR)[1:K] <- factor_names
Y_for_VAR <- ts(Y_for_VAR, start = start, frequency = frequency)
VARselect(Y_for_VAR)
p = VARselect(Y_for_VAR)$selection[1] # according AIC
var <- VAR(Y_for_VAR, p)
y_hat <- forecast(var, h=h)
y_name <- colnames(Y_for_VAR)[K+num_y]
print(y_name)
forecast_class <- forecast_class_consturctor(
forecast = list(y_name = y_hat$forecast[y_name]),
model = var,
method = y_hat$method[K+num_y], y_name=y_name)
return(forecast_class)
}
fore_FAVAR(X, Y, X_slow, K, num_y = 3, num_i = 3, h = 1, y = Y[,3])
library("tidyverse")
library("forecast")
library("vars")
library("lmtest")
df <- read.csv("C:/Users/petrg/Desktop/Диплом/Code/my experiments/russia_ts_data.csv")
df <- read_csv("C:/Users/petrg/Desktop/Диплом/Code/my experiments/russia_ts_data.csv")
View(df)
df <- read_csv("C:/Users/petrg/Desktop/Диплом/Code/my experiments/russia_ts_data.csv", sep=';')
df <- read_csv("C:/Users/petrg/Desktop/Диплом/Code/my experiments/russia_ts_data.csv", del=';')
df <- read.csv("C:/Users/petrg/Desktop/Диплом/Code/my experiments/russia_ts_data.csv", sep = ';')
View(df)
colnames(df)[1] = 'Date'
class(df$Date[1])
ts <- ts(df$RSMTHWAG, start = c(2000,4))
ts
ts <- ts(df$RSMTHWAG, start = c(2000,4), frequency = 12)
ts
ts <- ts(df$RSCRDCONA, start = c(2000,4), frequency = 12)
ts
ts <- ts(df, start = c(2000,4), frequency = 12)
View(ts)
ts <- ts(df[-1], start = c(2000,4), frequency = 12)
ts
ts <- ts(df[-1, -2], start = c(2000,4), frequency = 12)
ts <- ts(df[-1, -1], start = c(2000,4), frequency = 12)
ts <- ts(df[-1], start = c(2000,4), frequency = 12)
View(ts)
ts <- ts(df[-'Date'], start = c(2000,4), frequency = 12)
ts <- ts(df[-c('Date')], start = c(2000,4), frequency = 12)
dim(df)
end_col <- dim(df)[2]
ts <- ts(df[,2:end_col], start = c(2000,4), frequency = 12)
ts <- ts(df, start = c(2000,4), frequency = 12)
df <- read.csv("C:/Users/petrg/Desktop/Диплом/Code/my experiments/russia_ts_data.csv", sep = ';')
View(df)
colnames(df)[1] = 'Date'
end_col <- dim(df)[2]
ts <- ts(df, start = c(2000,4), frequency = 12)
colnames(df)[1] = 'Date'
View(ts(df$RSCRDCONA, frequency = 12, start = c(2000,4)))
View(ts(df$RSGOVBALA, frequency = 12, start = c(2000,4)))
View(ts(as.double(df$RSCRDCONA), frequency = 12, start = c(2000,4)))
autoplot(Y[,3])
library("tidyverse")
library("forecast")
library("vars")
library("lmtest")
autoplot(Y[,3])
autoplot(forecast(ets(Y[,3]), h = 12))
autoplot(forecast(auto.arima(Y[,3]), h = 12))
autoplot(forecast(auto.arima(Y[,2]), h = 12))
library("readxl")
library("tidyverse")
library("forecast")
library("vars")
library("lmtest")
library("readxl")
setwd("C:/Users/petrg/Desktop/Диплом/Code/my experiments/")
source("my_tsCV.R")
for_modeling <- read_excel("C:/Users/petrg/Desktop/Данные для диплома/real_big_data.xlsx",
range = "R2C3:R242C296")
N_for_modeling <- dim(for_modeling)[2]
# Complete series only
complete_series_indices = c()
for(i in 1:N_for_modeling) {
if (sum(is.na(for_modeling[,i])) == 0) {
complete_series_indices = c(complete_series_indices, i)
}
}
df <- for_modeling[,complete_series_indices]
colnames(df) <- colnames(for_modeling)[complete_series_indices]
ts <- ts(df, start=c(2000,1), frequency = 12)
install.packages("dtwclust")
transformations <- rep(0, N)
N <- dim(ts)[2]
clust.pam <- tsclust(ts, type="partitional", k=6L, distance="dtw", clustering="pam")
T <- dim(ts)[1]
transformations <- rep(0, N)
# Standardize & SA for some reason (correct PCA extraction probably)
for (i in 1:N){
ts[,i] <- (ts[,i] - mean(ts[,i])) / sd(ts[,i])
#[,i] <- ts[,i] - stl(ts[,i], 'periodic')$time.series[,1]
transformations[i] <- ndiffs(ts[,i])
}
clust.pam <- dtwclust::tsclust(emissions.norm, type="partitional", k=6L, distance="dtw", clustering="pam")
clust.pam <- dtwclust::tsclust(ts, type="partitional", k=6L, distance="dtw", clustering="pam")
clust.pam <- dtwclust::tsclust(ts, type="partitional", k=63L, distance="dtw_basic", clustering="pam")
clust.pam <- dtwclust::tsclust(ts, type="partitional", k=3L, distance="dtw_basic", clustering="pam")
plot(clust.pam, type = "sc")
t(cbind(ts[,0], cluster = clust.pam@cluster))
t(cbind(colnames(ts), cluster = clust.pam@cluster))
clust.pam <- dtwclust::tsclust(ts, type="partitional", k=6L, distance="dtw_basic", clustering="pam")
plot(clust.pam, type = "sc")
Y[,1]
ts[,1]
autoplot(forecast(ets(ts[,1])))
autoplot(forecast(ets(ts[,16])))
